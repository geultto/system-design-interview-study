# 1. 문제 이해 및 범위 확정

### 규모

- **하루 100만 건** 거래 → **TPS(초당 거래 처리량) 10건**
- 성능보다 **정확성**이 최우선!

### 핵심 요구사항

**기능**

- 대금 수신 (Pay-in)
    - 결제 시스템이 판매자를 대신해 고객으로부터 대금을 수령
- 대금 정산 (Pay-out)
    - 배송 완료 등 조건이 충족되면 판매자에게 판매 대금을 송금
- 신용카드 결제만

**제약**

- PSP 활용
- 카드 정보 직접 저장 X
- 내부/외부 서비스 조정 필수

---

# 2. 시스템 구조

### 주요 컴포넌트

| 컴포넌트 | 역할 |
| --- | --- |
| **결제 서비스** | 프로세스 조율, 위험 점검 |
| **결제 실행자** | PSP 호출하여 결제 실행 |
| **PSP** | 실제 돈 이체 처리 |
| **원장 (Ledger)** | 모든 거래 기록 |
| **지갑 (Wallet)** | 판매자 잔액 관리 |

### 결제 흐름

![image.png](attachment:658798ba-f092-4a06-a2ab-1afb8c96cf88:image.png)

```
사용자 → 결제 서비스 → 결제 실행자 → PSP
                              ↓
                          지갑 업데이트 → 원장 기록

```

---

# 3. 핵심 개념

## 멱등성 (Idempotency)

> 동일한 연산을 여러 번 수행해도 최초 실행 결과가 그대로 보존되는 특성을 의미
> 

### 문제 상황

```
사용자: 결제 버튼 클릭
→ 네트워크 끊김 
→ 다시 클릭
→ 이중 결제??
```

### 해결: 멱등키 (Idempotency Key)

```
POST /v1/payments
Headers:
  Idempotency-Key: uuid-12345

→ 같은 uuid면 중복 처리 안 함 ✅
```

**구현 방법**

- UUID로 각 거래 식별
- DB 기본키로 구현
- 중복 insert 시도 → 실패 → 이전 결과 반환

---

## 재시도 (Retry)

### 재시도 전략

| 전략 | 설명 | 사용 시기 |
| --- | --- | --- |
| **즉시 재시도** | 바로 다시 시도 | 일시적 오류 |
| **고정 간격** | 일정 시간 후 | 가벼운 장애 |
| **증분 간격** | 1초→2초→3초... | 부하 고려 |
| **지수적 백오프** ⭐ | 1초→2초→4초→8초... | **권장!** |
| **취소** | 포기 | 영구적 실패 |

### 재시도 큐 시스템

```
[실패한 결제]
      ↓
┌─────────────┐
│  재시도 큐   │ → 다시 시도 (3회까지)
└─────────────┘
      ↓
┌─────────────┐
│ 실패 메시지  │ → 사람이 확인
│     큐      │
└─────────────┘

```

---

## 정확히 한 번 실행

### 수학 공식

```
정확히 한 번 = 최소 한 번 + 최대 한 번

```

| 구분 | 보장 방법 | 설명 |
| --- | --- | --- |
| **최소 한 번** | 재시도 ✅ | 실패해도 다시 시도 |
| **최대 한 번** | 멱등성 ✅ | 중복 처리 안 함 |

### 예시

**1) 더블 클릭**

```
클릭1: 멱등키 abc123
클릭2: 멱등키 abc123 (동일!)
→ 시스템: "이미 처리했어요"
→ 이전 결과 반환 ✅
```

**2) 네트워크 오류**

```
1. PSP 결제 성공
2. 응답 전달 실패 (네트워크)
3. 재시도 → 같은 토큰 전송
4. PSP: "이미 처리했어요"
5. 이전 결과 반환 ✅
```

---

# 4. 주요 설계 요소

## 조정 (Reconciliation)

> 매일 밤 장부 대조
> 

### 프로세스

```
매일 자정:
1. PSP/은행에서 정산 파일 수신
2. 우리 원장과 비교
3. 차이 발견 → 조사/수정
```

### 불일치 유형별 대응

| 유형 | 처리 방법 |
| --- | --- |
| 알고 있는 문제 + 자동화 가능 | ✅ 자동 수정 |
| 알고 있는 문제 + 자동화 불가 | ⚠️ 수동 수정 |
| 모르는 문제 | 🔍 조사 필요 |

**조정의 중요성**

- 결제 시스템의 **마지막 방어선**
- 시스템 간 데이터 일관성 보장
- 정산 파일과 원장 비교

---

## 복식부기 원장

> 모든 거래는 차변 + 대변!
> 

### 원칙

```
사용자 → 판매자 $100 결제

차변: 사용자 계좌 -$100
대변: 판매자 계좌 +$100
──────────────────────
합계: $0 ✅
```

### 장점

- 자금 흐름 **추적 가능**
- **일관성 보장**
- 감사(Audit) 용이
- 오류 발견 쉬움

---

## PSP 연동

> 참고: 책은 미국/글로벌 기준 설명. 한국은 직접 저장도 가능!
> 

### 외부 결제 페이지 흐름

```
1️⃣ 사용자 결제 버튼 클릭

2️⃣ 결제 서비스 → PSP 결제 등록
   - 멱등키: payment_order_id 포함

3️⃣ PSP → 토큰 반환

4️⃣ 토큰 DB 저장

5️⃣ PSP 결제 페이지 표시 (iframe/SDK)

6️⃣ 사용자 카드 정보 입력
   → PSP로 직접 전송! 🔒

7️⃣ PSP 결제 처리

8️⃣ 웹훅으로 결제 결과 전송

9️⃣ 결제 상태 업데이트

```

### 한국에서는?

**방법 1: PSP 사용 (책의 방식)**

- 토스페이먼츠, 포트원 등
- 카드 정보는 PSP가 저장
- 우리는 토큰만 보관

**방법 2: 직접 저장 (한국 가능)**

```
1️⃣ 사용자가 우리 결제 페이지에 카드 정보 입력
2️⃣ 카드 정보 암호화해서 DB 저장
3️⃣ 본인 동의 받기
4️⃣ 다음 결제 시 저장된 정보 사용
5️⃣ PSP는 은행 연결/카드사 지원만

→ 쿠팡, 네이버 등이 이 방식!
```

> 보안: 두 방식 모두 안전. PSP 방식은 책임 분산, 직접 저장은 UX 좋음
> 

---

## 동기 vs 비동기 통신

> 내부 서비스 통신에는 동기식과 비동기식 두 가지 패턴 존재
> 

### 비교표

| 방식 | 장점 | 단점 | 적합성 |
| --- | --- | --- | --- |
| **동기식** | 구현 간단 | 성능 저하, 결합도 높음 | 소규모 |
| **비동기식** | 확장성, 장애 격리 | 복잡, 일관성 문제 | **대규모 ✅** |

### 비동기 - Kafka 활용

**단일 수신자**

```
큐: [m1, m2, m3]
서비스A: m1 처리 → 큐에서 제거
서비스B: m2 처리 → 큐에서 제거
```

**다중 수신자** (Kafka)

```
Topic: [m1, m2, m3]
서비스A: m1 처리 (유지)
서비스B: m1 처리 (유지)
서비스C: m1 처리 (유지)

→ 하나의 결제로 푸시 알림, 재무 보고, 분석 동시 처리!
```

---

## 데이터 모델

### 결제 주문 테이블 스키마

```sql
CREATE TABLE payment_orders (
    payment_order_id VARCHAR(255) PRIMARY KEY,  -- 멱등키!
    checkout_id VARCHAR(255),                   -- FK
    seller_account VARCHAR(255),
    amount VARCHAR(50),      -- ⚠️ String 타입!
    currency VARCHAR(3),
    payment_order_status ENUM(
        'NOT_STARTED',
        'EXECUTING',
        'SUCCESS',
        'FAILED'
    ),
    wallet_updated BOOLEAN,
    ledger_updated BOOLEAN
);

```

### amount가 String인 이유

**잘못된 예**

```jsx
amount: 10000.50  // float/double
→ 반올림 오류 발생 가능!
```

**올바른 예**

```jsx
amount: "10000.50"  // string
→ 계산할 때만 숫자로 변환
```

### DB 선택

- ✅ **관계형 DB** (MySQL, PostgreSQL)
- ❌ NoSQL
- **이유**: ACID 트랜잭션 필수!

---

## 보안

### 주요 위협과 대응

| 위협 | 대응 방안 |
| --- | --- |
| 도청 | HTTPS |
| 데이터 변조 | 암호화 + 무결성 모니터링 |
| 중간자 공격 | 인증서 고정 + SSL |
| 데이터 손실 | 다중 지역 복제 |
| DDoS | Rate Limiting + 방화벽 |
| **카드 도난** | **토큰화** |
| 규정 준수 | PCI DSS |

---