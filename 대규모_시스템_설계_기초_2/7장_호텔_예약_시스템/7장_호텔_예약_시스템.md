# 목차

- 시스템 개요 및 규모 파악
- 핵심 문제: 동시성 이슈
- 해결 방법 3가지 비교
- 시스템 확장 전략

# 1. 시스템 개요

## 시스템 규모

- 호텔 : 5,000개
- 총 객실 : 100만개
- 일일 예약 : 24만건
- 초당 예약 : 약 3전

## 요구사항

- **높은 동시성 지원**: 여러 사용자가 동시에 예약
- **이중 예약 방지**: 한 방에 두 명 예약 불가
- **빠른 응답**: 수 초 내 예약 완료
- **초과 예약 허용**: 110%까지 예약 가능

## 사용자 행동 패턴

- 전환율 분석

```jsx
100명 접속
    ↓
객실 보기 (100명)
    ↓ 90% 이탈
예약 정보 입력 (10명)
    ↓ 90% 이탈
실제 예약 (1명)
```

- 읽기 연산이 압도적으로 많고,
- 쓰기 연산은 상대적으로 작기 때문에 “관계형 DB” 적합

# 2. 핵심 문제 : 동시성 이슈

## 문제발생

```jsx
오전 10시, 방 1개 남음

a : 예약 (클릭)
b : 예약 (0.1 초후 클릭)

결과 : 둘 다 예약 성공
```

## 왜 발생할까?

```jsx
순서 :
1. a : 방 있나 ? -> 1개 남음
2. b : 방 있나 ? -> 1개 남음
3. a : 예약 완료 (남은 방 0개)
4. b : 예약 완료 (남은 방 -1개)
```

이 문제에 대해 해결할 방법이 3가지는 아래와 같다.

1. 비관적 락
2. 낙관적 락
3. DB 제약조건

# 3. 방법 1: 비관적 락

## 개념

> 사용자가 특정 데이터를 변경하려고 할 때 즉시 락을 거는 방식이다.
> 
> 
> 다른 사용자가 락이 풀릴 때까지 기다려야 한다.
> 

## 작동 방식

```jsx
예) 화장실 비유

1. a 입장 → 문 잠금 
2. b 시도 → "사용 중"
3. b 대기 
4. a 완료 → 문 열림 
5. b 입장 가능 ✅
```

## 장단점

- 장점
    - **중간에 다른 사용자가 데이터를 건드릴 수 없음** → 데이터 정합성 보장
    - 구현이 쉽고 충돌 방지에 효과적
    - 업데이트가 중요한 상황에서 유용
- 단점
    - 속도가 느리다 (대기 시간 o)
    - 데드락 위험
    - 많은 사람 몰리면 시스템 마비

<aside>
💡

실제 호텔 예약 시스템에서는 권장하지 않는다

</aside>

# 3. 방법 2: 낙관적 락

## 개념

> 여러명의 사용자가 동시에 데이터 갱신을 시도하는 것을 막지 않는 락이다. 낙관적 락에서는 갱신 “시도”를 막지 않는다.
> 

하지만 최종 버전에 반영되는건 단 1개뿐이다. 

채택되지 못한 트랜잭션의 갱신 시도는 그대로 무시되며, 사용자 입장에서는 계속해서 재시도를 해야 한다. 최종 결제 버튼까지 눌렀더니 “오류가 발생했습니다. 다시 시도해주세요.” 같은게 뜨는 것이다.

![image.png](attachment:1cc4be2c-b8ed-4600-9956-d8e6520ebae8:image.png)

## 버전 관리 방식

- 버전 번호가 있는 열을 데이터 테이블에 추가한다..
- 사용자가 데이터를 읽으면, 현재 버전 번호도 같이 읽는다.
- 사용자가 수정을 마치고 제출할 때, **버전 번호를 1 증가**시켜 제출한다. (v2로 기록).
- **제출 전에 유효성 검사**를 한다.
    - 내가 처음 읽은 버전이 아직도 그대로면 → 성공
    - 이미 다른 사용자가 바꿔서 버전이 바뀌었으면 → **실패 (충돌)**

**즉, 실제로 실행한다면 모두가 같은 버전 번호(v1)를 기준으로 예약을 시도할 수 있음 → 한 명만 성공하고 나머지는 실패한다.**

### 작동방식

```jsx
초기 상태:
┌─────────────────┐
│ 킹룸 (v1)       │
│ 남은 방: 1개    │
└─────────────────┘

a 예약:
"v1 방 예약" → 성공 (v2로 변경)

b 예약:
"v1 방 예약" → 실패 
"지금은 v2입니다"
```

## 실제SQL

```jsx
-- Step 1: 버전 확인
SELECT room_id, available, version 
FROM rooms 
WHERE room_id = 101;
-- 결과: available=1, version=5

-- Step 2: 예약 시도 (버전 체크!)
UPDATE rooms 
SET available = 0, version = 6
WHERE room_id = 101 AND version = 5;

-- 성공: 버전 맞음 
-- 실패: 버전 틀림 → "다시 시도하세요" 
```

## 장단점

- 장점
    - 빠른 속도 : 락 없음
    - 높은 효율성
    - 확장성 : 서버 추가 용이
- 단점
    - 경쟁이 심해지면  성능 떨어진다
    - 반복 실패 가능성으로 사용자가 불편함

<aside>
💡

콘서트 티켓팅 같이 초당 예약이 높은건 다른 방법 고려할 필요가 있다

</aside>

# 3. 방법 3: DB 제약조건

## 개념

> 예약 가능 수량이 0개 미만으로 떨어지지 않도록 **DB 테이블 자체에 조건을 걸어** 막는 방법이다
> 
> 
> CHECK 제약 조건을 사용해서 **예약 가능한 범위를 초과하면 트랜잭션 자체가 실패**하게 만든다.
> 

```jsx
-- 규칙 설정
CHECK (total_inventory - total_reserved >= 0)
```

## 작동 방식

```jsx
총 방: 100개
예약: 99개

a 예약 → 예약: 100개 ✅
b 예약 → 예약: 101개 ❌ 자동 차단!
```

## 장단점

- 장점
    - 구현이 간단하다
    - 경쟁이 심하지 않은 경우에는 빠르고 잘 동작한다
- 단점
    - 동시에 여러 사용자가 들어올 경우 거의 다 실패 → **반복 시도 증가**
    - 사용자 입장에선 "분명 있던 방이 갑자기 없다"는 오류 메시지를 계속 보게 된다.

# 4. 시스템 확장 전략

만약 부킹닷컴 등 처럼 트래픽이 많다면? 아래와 같이 두가지 방법에 대해 생각해볼 수 있다

- 샤딩
- 캐시

## 확장 방법 1: 샤딩

### 개념

> **DB 부하를 줄이고 확장성을 확보**하는 방식, 데이터를 여러 개의 데이터베이스(샤드)에 나눠서 저장
> 
> 
> 각 샤드는 전체 데이터의 일부만 저장하고 처리함
> 

![image.png](attachment:cf89ad0a-c2ee-46d9-8d51-6d2cc3848ff8:image.png)

그래서 예를 들면

QPS(초당 쿼리 수)가 30,000이면:

- 샤드 16개로 분산 → 1개 샤드당 1,875 QPS만 처리하면 된다
- MySQL 서버 1대당 감당 가능 수준이 된다.

## 확장 방법 2: 캐시

일단 캐시를 쓰는 이유는 호텔 예약 시스템에서 "잔여 객실 수"를 **빠르게 보여주기** 위해 캐시를 쓴다.

### 작동 구조

```jsx
사용자 요청
    ↓
┌─────────────┐
│ 캐시 확인   │ ← 1차 (빠름)
└─────────────┘
    ↓ 없으면
┌─────────────┐
│ DB 확인     │ ← 2차 (정확)
└─────────────┘
    ↓
결과를 캐시에 저장
```

잔여 **객실 수 조회** 요청이 오면, 먼저 **Redis 기반 캐시**에서 조회

- 캐시에 없거나 오래된 데이터일 경우 → **DB조회**

**예약 생성**이 일어나면, DB에 total_reserved 값을 업데이트

- **캐시도 비동기적으로 갱신**

### 데이터구조 : key-value 저장

```jsx
키: hotel_ID + roomType_ID + 날짜
값: 남은 객실 수

예시:
┌────────────────────────────────┐
│ hotel_1_king_20251225    : 5   │
│ hotel_1_queen_20251225   : 3   │
│ hotel_2_suite_20251226   : 1   │
└────────────────────────────────┘
```

### 캐시의 데이터 불일치 문제 상황

```jsx
1. 캐시: "방 1개 남음" (구 데이터)
2. 누군가 예약 → DB 업데이트
3. DB: "방 0개" (최신 데이터)
4. 캐시: 여전히 "1개" (아직 반영 안 됨)

→ 불일치!
```

### 해결책 : 2단계 검증

```jsx
1차: 캐시 확인 (빠른 선별)
    ↓
2차: DB 최종 확인 (정확한 검증)
    ↓
결과: "죄송합니다, 방이 없습니다"
```

> DB가 최종 판결
> 

## 서비스 간 데이터 일관성

### 모놀리스 아키텍처

- 예약 서비스, 객실 수 계산, 결제 서비스 등 **모두 하나의 DB**를 씀
- 하나의 **트랜잭션**으로 묶어서 처리 가능 → ACID 보장됨 (**ACID**는 데이터베이스 트랜잭션이 **신뢰성과 일관성을 보장**하기 위해 지켜야 할 네 가지 속성이다)동시에 여러 사람이 예약해도 데이터가 꼬이지 않음

### 마이크로 서비스 아키텍처

![image.png](attachment:84f72508-357f-4761-934e-4a4b4db5f78e:image.png)

- 호텔, 요금, 예약, 결제 서비스가 각자 DB를 갖고 있음
- 이때는 하나의 트랜잭션으로 묶을 수 없음
- 예: 잔여 객실은 1개인데 동시에 2명이 예약하면 각자 다른 DB를 참조해서 둘 다 성공하는 오류 발생 가능

### MSA의 데이터 일관성 문제

### 1. 2단계 커밋(2PC)

- 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜이다.
- **모든 노드가 성공하든, 실패**하든 둘 중 하나로 트랜잭션이 마무리되도록 보증한다.
- 비중단 실행이 가능한 프로토콜이 아니여서 (blocking-protocol) 어느 한 노드에 장애가 발생하면 해당 장애가 복구될때까지 진행이 중단된다.

### 2. 사가(SAGA)

- 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은것이라 보면 된다.
- 각각의 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만들어 보낸다.
- 어느 한 트랜잭션이라도 실패하면 사가는 그 이전 트랜잭션의 결과를 전부 되돌린다
    - 역순으로 실행한다.
- 실패 시나리오

```jsx
진행 상황:
1. 객실 차감 ✅ (저장됨)
2. 예약 생성 ✅ (저장됨)
3. 결제 처리 ❌ (카드 한도 초과)

보상 흐름 (역순으로):
   
Step 1: 결제 보상
- 이미 실패했으니 할 것 없음

Step 2: 예약 보상
┌─────────┐
│ 예약 DB │ → 예약 레코드 삭제
└─────────┘

Step 3: 객실 보상
┌─────────┐
│ 객실 DB │ → 차감된 객실 수 복구
└─────────┘

→ 원상 복구 완료!
```

SAGA는 완벽한 일관성은 보장하지 못하지만, 최종적 일관성을 제공합니다. 호텔 예약처럼 몇 초의 불일치가 허용되는 시스템에는 적합합니다.

<aside>
💡

**카톡에 비유**

- 강한 일관성: 모든 친구가 동시에 메시지 받을 때까지 대기
- 최종 일관성: 일단 보내고, 각자 시간차로 도착
</aside>

# 정리

호텔 예약 시스템 설계에서 가장 중요한 세 가지 포인트는 다음과 같다.

### 1. 동시성 제어: 낙관적 락

- 여러 사용자가 동시에 같은 객실을 예약하려는 상황에서 **버전 관리 기반 낙관적 락**이 가장 적합하다
- 호텔 예약의 경우 초당 예약 건수가 3건 정도로 경쟁이 심하지 않기 때문에 효율적이다
- 비관적 락은 안전하지만 성능이 떨어지고, DB 제약조건은 구현이 간단하지만 사용자 경험이 좋지 않다

### 2. 시스템 확장: 샤딩과 캐시

- 트래픽이 증가하면 **샤딩**을 통해 데이터를 분산 저장하고, **캐시**를 통해 조회 성능을 100배 향상시킬 수 있다
- 캐시는 빠른 조회를 제공하지만, **DB가 최종 판결자** 역할을 해야 한다
- 캐시와 DB 간 데이터 불일치는 2단계 검증(캐시 선별 → DB 확인)으로 해결한다

### 3. 데이터 일관성: SAGA 패턴

- MSA 환경에서는 각 서비스가 독립적인 DB를 가질 수 있다
- 2PC는 완벽한 일관성을 보장하지만 느리고 확장성이 낮다
- **SAGA 패턴**은 최종적 일관성을 제공하며, 보상 트랜잭션을 통해 실패 시 되돌린다
- 호텔 예약처럼 몇 초의 불일치가 허용되는 시스템에 적합하다

끝.