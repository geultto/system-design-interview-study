# 역사

2005년 ‘프로젝트 구글 맵’을 발족하고 웹 기반 지도 서비스를 개발

### 서비스

- 위성 이미지
- 거리뷰
- 실시간 교통 상황
- 경로 계획

### 그 외

- DAU 는 10억명
- 전 세계 99% 지역 지도 제공
- 정확한 실시간 위지 정보를 제공 → 일 2500만 건의 업데이트 반영

# 1단계: 문제 이해 및 설계 범위 확정

## 가정

- 10억 DAU
- 위치 갱신, 경로안내, ETA, 지도 표시
- 도로 데이터-수 TB 수준의 가공되지 않은 데이터
- 교통 상황 고려(도착 시간 최대한 정확하게 추정을 위해)
- 다양한 이동 방법

### 고려하지 않음

- 경유지
- 사업장 위치 및 사진

## 1) 기능 요구사항

아래 세가지 기능에 집중

1. 사용자 위치 갱신
2. 경로 안내 서비스 (ETA 포함)
3. 지도 표시

## 2) 비기능 요구사항 및 제약사항

- 정확도 : 잘못된 경로 안내 X
- 부드러운 경로 표시
- 데이터 및 배터리 사용량은 최소한으로
- 널리 통용되는 가용성 및 규모 확장성 요구사항 만족

## 3) 기본 개념 및 용어

### 측위 시스템

세계는 축을 중심으로 회전하는 구다. 측위 시스템은 이 **구 표면 상의 위치를 표현**하는 체계

위경도 기반 측위 시스템인 경우,  최상단에는 북극이있고, 최하단에는 남극이 있다

- 위도: 주어진 위치가 얼마아 북/남쪽인지를 표현
- 경도: 얼마나 동/서쪽에 있는지 표현

### 지도 투영법(또는 도법)

3차원 구 위의 위치를 2차원 평면에 대응시키는 절차

- 메르카토르 도법

![image.png](attachment:030d8347-a181-4258-a0c0-b4d9cc2d39ff:image.png)

구글 맵은 위 사진의 도법을 조금 변경한 웹 메르카토르 도법을 사용

### 지오코딩

주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스

```jsx
“서울특별시 강남구 테헤란로 427” 같은 글자 형태 주소를
“위도 37.5098, 경도 127.0620” 같은 숫자 좌표로 바꿔주는 것.
```

### 지오해싱

지도 위  특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계

2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할

![image.png](attachment:dc3384b1-1340-4a56-8cdb-6aaa3ade2955:image.png)

### 지도표시

지도를 화면에 표시하는데 가장 기본이 되는 개념은 **타일**

지도 전부를 하나의 이미지로 표시하는 대신, 작은 타일로 쪼개어 표시

사용자가 보려는 영역에 관계된 타일만 다운받아 모자이크처럼 이어 붙인 다음 화면에 뿌림

## 4) 경로 안내 알고리즘을 위한 도로 데이터 처리

경로 탐색  알고리즘은 **다익스트라 알고리즘**이나 **A* 경로 탐색 알고리즘**의 변종임

[[알고리즘] 다익스트라 알고리즘 (Dijkstra Algorithm)](https://twd0622.tistory.com/107)

[[알고리즘] A* (에이 스타) 알고리즘](https://twd0622.tistory.com/108)

중요한 것은 모든 경로 탐색 알고리즘은 교차로를 노드로, 도로는 노드를 잇는 선(edge)로 표현하는 그래프 자료 구조를 가정한다는 것

![image.png](attachment:8165395c-c523-4e0e-a541-a24cda73ac81:image.png)

- 알고리즘의 성능은 그래프 크기에 아주 민감함, 그래서 좋은 성능을 보이려면 그래프를 관리 가능 단위로 분할해야함
- 지오해싱과 비슷한 분할 기술을 적용하여 작은 격자로 나누고, 각 격자 안의 도로망을 노드(교차로)와 선(도로)으로 구성된 그래프 자료 구조로 변환.
- 각 격자는 경로 안내 타일이라고 부름
- 각 타일은 도로로 연결된 다른 타일에 대한 참조를 유지

    ![image.png](attachment:92fe53e7-d2fb-4bff-830c-e7cde2adcb70:image.png)


언제든 불러올 수 있는 경로 안내 타일로 분할해 놓으면 경로 탐색 알고리즘이 동작하는 데 필요한 메모리 요구량을 낮출 수 있고, 처리해야 하는 양이 줄어들고, 성능도 좋아짐

<aside>
💡

지도 타일은 PNG 이미지인 반면, 경로 안내 타일은 도로 데이터로 이루어진 이진(binary file)이다

</aside>

### 계층적 경로 안내

경로 안내가 효과적으로 동작하려면 필요한 수준의 구체성을 갖춘 도로 데이터가 필요

- 구체성 정도
    - 상 : 크기가 아주 작으며, 지방도 데이터
    - 중 : 규모가 비교적 큰 관할구를 잇는 간선도로 데이터
    - 하 : 도시와 주를 연결하는 주요 고속도로 데이터

## 5) 계략적 규모 추정

풀어야할 문제 규모를 간단히 추정해보자

- 1 피트 = 0.3048미터
- 1km = 0.6214마일
- 1km = 1,000미터

### 저장소 사용량

아래 세가지 데이터 저장

1. 세계 지도
2. 메타데이터 : 크기가 아주 작아 본 추정에서는 제외
3. 도로 정보 : 외부에서 받은 수 TB용량의 도로 데이터

이 데이터를 경로 안내 타일로 변환하여야 한다. 변환 결과의 용량도 비슷할 것,

타일 전부를 보관하는 데 필요한 용량을 가늠하려면 최대 확대 수준, 즉 지도를 최대한 확대하여 보는 데 필요한 타일 개수를 따져 봐야 한다.

지도를 확대할 때 마다 하나의 타일을 네 장의 타이로 펼친다고 가정하자. 세계 지도를 *21번* 확대하여 볼 수 있으려면 약 4.4조 개의 타일이 필요하다.

![image.png](attachment:9a257d50-5ae5-4d6b-8cf1-d736258815de:image.png)

하지만 지구 표면의 약 90%는 바다, 사막, 호수, 산과 같은 자연적이고 대부분 사람이 살지 않는 지역입니다. 더욱이 이러한 지역은 이미지 압축률이 매우 높기 때문에, 저장 용량을 80~90%, 예를 들어 50GB 정도로 보수적으로 줄일 수 있습니다.

## 서버 대역폭

서버가 처리해야하는 요청은 크게 두가지

1. **경로 안내 요청**으로, 클라이언트가 경로 안내 세션을 시작할 때 전송하는 메시지
2. **위치 갱신 요청**으로, 클라이언트가 경로 안내를 진행하는 동안 변경된 사용자 위치를 전송하는 메세지

경로 안내 요청을 처리하기 위한 서버 대역폭을 분석해 봅시다.

- DAU 10억
- 사용 시간 : 주당 35분
- (35*10억명)/7 = 50억분

초로 변경하면 3000억. 3000억을 하루를 초로 변환한 값을 어림잡아 나누면, 3000억/10^5 = 3백만 QPS 이 됩니다.

<aside>
💡

QPS: 1초에 처리할 수 있는 요청 수

</aside>

다만 이는 GPS 좌표를 매 초 서버로 전송한다 가정한 것이고, 그렇게 업데이트를 자주할 필요가 없기 때문에 이를 15초 주기로 보내도록 설정

그렇게 되면, 3백만 / 15 = 20만, 즉 QPS 는 20만이 됩니다.

최대 QPS 는 평균치의 다섯배, 1백만이라고 가정할 수 있습니다.

# 2단계 : 개략적 설계안

![image.png](attachment:4bcacfad-8333-4d62-a9e9-94cfb97d1d80:image.png)

다음 세가지 기능을 제공한다.

## 1) 위치서비스

위치 서비스는 그냥 15초동안은 클라이언트내에서 위치정보를 업데이트하다가 서버에게 일괄 요청하는 형태.

하지만, 이렇게 하더라도 위에서 추정했듯 높은 쓰기 요청을 하므로 카산드라 추천

통신 프로토콜은 http에 keep-alive를 추천함.(지속적 연결을 가지는 형태)

[[네트워크] HTTP Keep-Alive 란?](https://velog.io/@calis_ws/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-HTTP-Keep-Alive-%EB%9E%80)

**✔ 왜 HTTP keep-alive를 쓰라고 하는가?**

위치 요청을 계속 서버에 보내야 하는 구조이므로

- 매번 TCP 연결을 열고 닫지 말고
- 한 번 연결해놓고 여러 요청을 그대로 보내라

이러면 훨씬 빠르고 서버 부하도 줄어듦.

## 2) 경로 안내 서비스

“출발지 → 도착지”를 보내면, 서버는 ETA(도착 예상 시간)+경로를 계산해서 내려보냄.

**✔ 서버가 돌리는 것**

- 최단 경로 알고리즘 (다익스트라, A*)
- 교통 상황
- 도로 속도 제한

    등을 반영해서 경로 계산


**✔ 응답 내용**

- ETA(도착 예상 시간)
- turn-by-turn navigation 데이터
- “지오코딩 기반 값들” → 경로를 이루는 각각의 좌표들(lat, lng)

## 3) 지도 표시

지도는 매번 그릴 필요 없고, 미리 잘라둔 이미지 조각(타일)을 요청해서 보여주면 된다.

**✔ 클라이언트에서 하는 일**

사용자의 현재 위치 + 지도 확대 수준(zoom level)을 사용해서

1. 지금 보여줘야 할 지도 영역을 계산
2. 필요한 타일의 번호 리스트를 계산
3. 해당 타일을 서버(URL)에서 가져오기

<aside>
💡

지오해시 url:지역을 좌표로 저장하는 대신 **문자로 된 짧은 코드** 로 표현하는 방식

</aside>

이렇게 미리 만들어둔 정적 이미지는 cdn을 통해 제공한다.

<aside>
💡

cdn:전 세계 여러 곳에 파일을 미리 저장해두고, 가장 가까운 장소에서 빠르게 받아오게 해주는 네트워크 시스템

</aside>

# 3단계: 상세 설계

## 1) 위치 서비스와 상세 설계

### 1. 왜 Cassandra를 사용하는가?

사용자의 위치는 **매우 자주 업데이트되는 데이터(쓰기 중심)**이기 때문에

쓰기 성능과 확장성이 뛰어난 **Cassandra** 같은 분산 DB가 적합하다.

- 대량의 Write 처리에 강함
- 노드를 추가하여 수평 확장 가능
- 파티션 기반 구조로 특정 사용자 데이터 조회가 빠름

### 2. 데이터 모델 설계

### 저장 형태

사용자 위치 데이터는 다음과 같은 간단한 구조를 가진다.

- **Key:** (user_id, event_timestamp)
- **Value:** (latitude, longitude)

즉,

누가(user_id) / 언제(event_timestamp) / 어디에 있었는지(latitude, longitude)를 저장하는 구조이다.

### 3. 파티션 키 & 클러스터링 키 설정

### 파티션 키: `user_id`

- 동일 사용자의 위치 정보가 한 파티션(=한 노드)에 모임
- → 특정 사용자의 위치 이력을 조회할 때 빠름
- → “이 사용자의 최근 위치 가져오기” 같은 쿼리 최적화

### 클러스터링 키: `event_timestamp`

- 같은 사용자 파티션 내에서 데이터를 시간 기준으로 정렬
- → 최근 N개 위치 조회
- → 특정 기간(예: 최근 10분) 조회

    를 효율적으로 처리 가능


### 4. 실시간 스트리밍 처리 (Kafka)

사용자 위치를 DB에 기록하는 것과 별개로, 카프카같은 데이터 스트리밍 플랫폼을 통해 실시간 교통 상황 서비스 등의 개별 서비스로 위치 데이터 스트림을 전달하도록 설계

![image.png](attachment:1c64f360-902f-4cc0-ada6-89238ee9901a:image.png)

## 2) 경로 안내 서비스와 상세 설계

경로 안내 기능은 하나의 서비스가 모든 일을 하는 것이 아니라, 각 역할별로 나누어진 여러 컴포넌트가 단계적으로 협력하는 구조로 설계

![image.png](attachment:b7c30c99-7f1f-416f-aa68-4d6164b325fd:image.png)

전체 흐름

1. 사용자가 출발지/도착지를 입력
2. **경로 안내 서비스**가 **지오코딩 서비스**를 호출해 (위도, 경도) 좌표를 획득
3. 좌표를 전달하여 **경로 계획 서비스**를 호출
4. 경로 계획 서비스는 여러 하위 기능(최단 경로, ETA 예측, 경로 필터링 등)을 조합해 최종 추천 경로를 반환

### a) 최단 경로 서비스

- 출발지와 도착지의 **위/경도**를 입력으로 받는다.
- 객체 저장소(S3 등)에 저장된 **그래프 기반 경로 타일 데이터**를 이용해 **여러 개의 최단 경로 후보**를 계산해 반환한다.
- 이 단계에서는 **교통 상황을 고려하지 않는다**

    → 오직 “거리 기준 최단 경로”만 계산

- 경로 타일 데이터는 거의 변하지 않는 **정적 데이터**이기 때문에

    **캐시(메모리 캐시, Redis 등)를 적극 활용**하여 성능을 높일 수 있다.


### b) 예상 도착 시간 서비스

- 최단 경로 서비스가 반환한 **경로 후보들**을 입력으로 받는다.
- 각 경로에 대해 **실제 이동 시간(ETA)** 을 예측한다.
- 방식:
    - 과거 교통량 데이터를 기반으로 **머신러닝 모델**을 학습
    - 현재 교통 상황(혼잡도, 사고, 날씨 등)을 입력으로 받아 ETA 산출

### c) 순위 결정 서비스

- 최단 경로 + ETA 정보를 모두 받은 뒤,

    **사용자 조건을 반영해 최종 추천 경로를 결정**한다.


예시:

- 도보만 가능
- 유료 도로 제외

## 🔍 필터링 적용 시점?

1. **경로 자체를 만들기 전에 제외할 수 있는 조건(고속도로 제외, 유료도로 제외 등)은 앞단에서 필터링**하여 불필요한 그래프 탐색 비용을 줄인다.
2. 이렇게 하면 최단 경로 서비스가 훨씬 적은 후보 경로만 계산해 성능이 좋아진다.
3. **하지만 소요 시간, 교통 상황, ETA 기반 조건은 반드시 ETA 계산 이후에 적용해야 한다.**
4. ETA는 모든 후보 경로의 이동 시간을 알아야 비교·정렬할 수 있기 때문이다.
5. 따라서 **“구조적 필터는 앞단, 의미적(ETA 기반) 필터는 뒷단”이라는 2단계 필터링 방식이 가장 효율적이다.**

## 3) 중요 정보 갱신 서비스

경로 안내 과정에서 필요한 여러 핵심 데이터는 시간이 지나면서 달라지기 때문에, 이를 최신 상태로 유지하는 서비스 필요

### 역할

- Kafka로부터 **위치 데이터 스트림을 구독**
- 스트림을 기반으로 **교통 상황, 평균 속도, 혼잡도, 사고 발생 정보 등**을 비동기적 업데이트
- 업데이트된 정보는
    - *실시간 교통 정보 데이터베이스*
    - *경로 안내 타일*

        등에서 즉시 반영될 수 있도록 한다.


### 예시

- 실시간 교통 정보 DB
- 경로 안내 타일(도로망 그래프의 부분 단위)

이 서비스 덕분에 경로 안내의 정확도가 유지

## 4) 적응형 ETA 및 경로 재계산

기본 설계에서는 경로 안내를 시작하면 **ETA(도착 예상 시간)와 경로를 고정**한다.

하지만 실제 교통 상황은 계속 변하므로, 이를 반영하려면 **적응형 ETA(Adaptive ETA)** 기능 필요

### 왜 어려운가?

교통 상황이 바뀔 때마다, 경로 안내 중인 **모든 사용자**에 대해

— 해당 사용자의 경로가 영향을 받는지 —

확인해야 하는데, 여기서 큰 비용이 발생한다.

### 🔸 문제점: O(n * m) 시간 복잡도

- 경로 안내 중인 사용자 수 = n
- 각 사용자의 경로에 포함된 도로 레코드 수 = m

```jsx
user_1: r_1, r_2, r_3, ..., r_k
user_2: r_4, r_6, r_9, ..., r_n
user_3: r_2, r_8, r_9, ..., r_m
..
```

예를 들어 r_2에서 사고가 나면, 모든 사용자 경로를 전수 조사해야 그 영향을 받는 사용자를 찾을 수 있다.

## 5) 타일 기반의 효율적 사용자 추억

이 문제를 해결하기 위한 접근법은 **“경로를 구성하는 타일 계층을 함께 저장하는 것”**이다.

### 방식

각 사용자가 경로 안내를 받고 있다면

그 사용자의 경로가 포함하는:

- 현재 타일
- 그 상위 타일
- 또 그 상위 타일…
- 출발지와 목적지가 모두 포함된 가장 큰 상위 타일까지

이 모든 타일을 **계층적으로 저장**해둔다.

### 장점

어떤 타일에서 교통 사고가 발생하면 그 타일이 속한 계층 정보를 바탕으로 “그 타일에 영향을 받는 사용자”만 빠르게 찾을 수 있다.

### 시간 복잡도: O(n)

전수조사 O(n * m)보다 훨씬 효율적이다.

## 6) 전송 프로토콜 선택

ETA 변경이나 경로 변경은 사용자 기기에 **실시간으로 전달해야 하는 정보**이다.

### 모바일 푸시 알림의 한계

- 메시지 크기 제한
- 도착 보장 X
- 즉시성 부족

    → 경로 변경에 적합하지 않음


### 웹소켓(WebSocket)의 장점

- **실시간 양방향 통신 지원**
- 서버 부담이 크지 않음
- 안정적인 커넥션 유지
- 즉시 업데이트 가능

예시 상황:

- 교통사고로 ETA가 5분 늘어났을 때 즉시 사용자에게 알려야 하는 경우
- 택배·퀵서비스 등 이동체가 목적지에 가까워졌을 때 실시간 업데이트 필요할 때

따라서 **웹소켓 기반 실시간 통신**이 가장 적합한 선택지이다.

![IMG_0909.heic](attachment:866af099-67d1-4a35-96da-ecf879f84a6e:IMG_0909.heic)