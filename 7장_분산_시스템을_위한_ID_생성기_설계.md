분산 시스템에서 auto_Increment 속성이 설정된 관계형 데이터베이스의 기본키 사용은 분산 환경에서 좋지 못함

→ 분산 시스템 환경에서 데이터 베이스 서버 한대로는 요구 감당 할 수 없음

→지연 시간을 낮추기가 힘듬

**분산 시스템 환경에서 유일성이 보장되는 ID 방식들을 사용해야 함**

### **1단계 문제 이해 및 설계 범위 확정**

적절한 질문을 통해 모호함을 없애고 설계 방향을 정해야 함.

- ID는 유일해야 한다.
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현할 수 있는 값이어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있어야 한다.

### **2단계 개략적 설계안 제시 및 동의 구하기**

요구 사항에 따른 유일성이 보장되는 ID를 만드는 방법은 아래 중 고려할 수 있음

- 다중 마스터 복제 (multi-master replication)
- UUID (Universally Unique Identifier)
- 티켓 서버 (ticket server)
- 트위터 스노플레이크 접근법 (twitter snowflake)

**다중 마스터 복제(mutli-master replication)**

데이터베이스의 auto-increment를 1만큼 증가가 아닌 데이터베이스 서버 수 만큼 증가시키는 방법. 

예시(서버 3대, S=3):

- 서버A(offset=1): 1, 4, 7, 10, ...
- 서버B(offset=2): 2, 5, 8, 11, ...
- 서버C(offset=3): 3, 6, 9, 12, ...

장점

- 데이터 베이스 수를 늘리면 초당 생성 가능ID 수를 늘릴 수 있음.

단점

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움 → 복제 복잡도 증가, 충돌 해결 비용
- ID의 유일성이 보장되겠지만, 시간 흐름에 맞추어 커지도록 보장할 수는 없음
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어려움

**UUID (Universally Unique Identifier)**

컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 자리 수로 아이디를 생성하는 방법.

장점

- 충돌 가능성이 지극히 낮음. → 1초에 10억 개(1e9)씩 85년간 생성해야 겨우 50% 확률로 한 번의 충돌
- 서버 간 조율 없이 독립적으로 생성 가능. → 규모 확장이 용이함
- 서버 사이의 조율이 필요 없어서 동기화 이슈 없음.

단점

- ID가 128비트로 김
- ID를 시간순으로 정렬할 수 없음 → 시간순 증가를 보장하지 않으므로 “최신순”을 PK로 바로 쓰기 힘듦
- ID에 숫자 아닌 값이 포함될 수 있음

**티켓 서버 (ticket server)**

auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것.

[App 서버 A] ───┐
│
[App 서버 B] ───▶│ 티켓 서버(DB) ─▶ AUTO_INCREMENT로 ID 발급
│
[App 서버 C] ───┘

장점

- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있음
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합.

단점

- 티켓 서버가 SPOF(Single-Point-of-Failure) 발생 가능. 서버에서 장애가 생기면 모든 시스템이 영향을 받음.
    
    → 이를 위해 티켓 서버를 여러 대 준비하게 된다면, 데이터 동기화 같은 새로운 문제 발생
    
- 확장성 한계 **:** ID 발급 요청이 몰리면 티켓 서버가 병목이 됨.

*Flickr의 분산 기본키 시스템

- 티켓 서버 구조를 개선해서 **단일 장애점 없이도 전역 유일 ID를 생성**할 수 있는 구조
- 이후 **Twitter Snowflake** 같은 시스템의 기초 아이디어

**트위터 스노플레이크 접근법 (Twitter snowflake)**

생성해야 하는 ID의 구조를 여러 절로 분할하는 것. 

ID는 64비트로 표현할 수 있는 값이어야 한다. 요구 사항에 따라 아래와 같이 설계.

64비트(big int) 아이디 구조

1비트(sign) | 41비트(timestamp) | 5비트(datacenter id) | 5비트(server id) | 12비트(sequence)

- 사인(sign) 비트 : 나중을 위해 유보해주는 값(부호비트 예약).→  나중에 다른 용도로 사용할 가능성을 열어두기 위함이기도 하고, ID 값이 음수가 되는 혼란을 막기 위해서
- 타임스탬프(timeStamp) : 기원 시작으로 몇 밀리초가 경과했는지를 나타내는 값, 
이 비트가 가장 상위에 있으므로, ID끼리 크기 비교하면 **시간순 정렬(time-sortable)**
- 데이터 센터 ID : 데이터 센터 ID, 비트면 `2^5 = 32`개의 값(0..31)을 표현 가능
- 서버 ID : 데이터 센터 당 서버 ID. 데이터센터 내부에서의 노드(worker) 식별자. 데이터 센터당 32개 서버 사용 가능
- 일련번호 : 각 서버에서 ID를 생성할 때마다 일련번호를 1만큼 증가. 1밀리초가 경과할 때마다 0으로 초기화
→만약 한 서버에서 1밀리초 동안 여러 개의 ID를 만들어야 한다면 어떻게 될까요? 타임스탬프, 데이터센터 ID, 서버 ID까지 모두 똑같아져 ID가 중복될 위험을 방지하기 위해 사용

**장점**

- 정수(64비트)라 DB 인덱스에 적합(문자열 UUID보다 작고 빠름).
- 시간 정렬 가능(대부분의 작업에서 유용).
- 중앙 티켓 서버 불필요(오프라인에서도 ID 생성 가능, 단일 장애점(SPOF)x).

**단점** 

- **동일 workerId 할당 보장**을 위한 외부 조율 필요.
- timestamp 비트가 한정되어 있어 수십년 후에는 재설계 필요.
- 다중 DC 환경에서 clock skew가 크면 시간 정렬성 신뢰도가 떨어짐.
→**클럭 스큐(Clock Skew)**: 여러 서버의 시계가 미세하게 서로 다른 시간을 가리키는 현상

### **3단계 상세 설계**

1단계 요구 사항에 모두 일치하는 트위터 스노플레이크 접근법으로 상세 설계. 

ID 생성 시기

- 데이터 센터 ID나 서버 ID는 시스템이 시작할 떄 결정되는 값. →운영 중에서 바뀌지 않으나, 두개의 ID를 잘못 변경하게 되면 ID 충돌이 일어날 수 있기 때문에 작업 시 신중하게 할 것.
- 타임스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어지는 값.

**타임 스탬프**
41비트는 총 $2^{41}$개의 밀리초를 표현할 수 있는데, 이는 약 **69년**에 해당하는 시간

→ 기원 시점(Epoch) 재설정, 비트(Bit) 재조정, ID 버전(Version) 도입

**일련번호**

일련번호는 12비트이므로, 4096개의 값을 가질 수 있다. 어떤 서버가 같은 밀리초 동안 하나 이상의ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.

### **4단계 마무리**

추가적으로 나올 수 있는 이슈

- 시계 동기화(clock synchronization) : 클럭 스큐(Clock Skew)가 심해지면, 시간에 맞지 않는 ID가 발급 될 수 있음
    - NTP(Network Time Protocol) 해결책
    : **NTP**는 "**시간을 맞춰주는 방송”.**  전 세계적으로 매우 정확한 기준이 되는 '원자시계'가 있고, 각 서버들은 주기적으로 이 기준 시계나 다른 상위 서버에 "지금 몇 시야?"라고 물어봐서 자신의 시간을 미세하게 조정함.
- 각 절(section)의 길이 최적화 : 동시성(concurrency)이 낮고 수평이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적
- 고가용성(high availability) : ID 생성기는 필수 불가별(mission critical) 컴포넌트이므로 아주 높은 가용성을 제공해야함. → 만약 ID 생성 시스템 전체가 멈춘다면, 서비스는 사실상 마비 상태에 빠짐