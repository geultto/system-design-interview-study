## 1. 문제 이해 및 설계 범위 확정
- **지원 채널:** 푸시 알림, SMS, 이메일
- **지원 플랫폼:** iOS, Android, 데스크톱/랩톱 (웹)
- **성능 특성:** 약간의 지연이 허용되는 **연성 실시간(Soft Real-time)** 시스템.
- **호출 방식:** 클라이언트 또는 서버에서 발생하는 이벤트를 기반으로 스케줄링 및 전송 요청.
- **사용자 기능:** 사용자가 직접 알림 수신 여부를 설정하는 기능 제공.
- **예상 처리량 (일일):**
    - 푸시 알림: 1,000만 건
    - SMS: 100만 건
    - 이메일: 500만 건


---
## 2. 개략적 설계안 제시 및 동의 구하기
### 개략적 설계안 (초안)
![](https://velog.velcdn.com/images/hjinshin/post/a9a313ae-6669-4461-8fa5-9439afd75190/image.png)

- 구성 요소
    - 단일 알림 서버
    - 알림 시스템을 호출하는 N개의 클라이언트 애플리케이션
    - 알림을 실제로 전달하는 서드파티 서비스
- 제 3자 제공 서비스(서드 파티 서비스)는 사용자에게 알림을 실제로 전송하는 역할을 한다. 이때 유의할 것은 확장성이다. 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다.

#### 문제점
이 설계에는 몇 가지 **문제**가 있다.

- **SPOF**: 단일 서버이기 때문에 장애가 발생하면 서비스 전체의 장애로 이어진다.
- **규모 확장성**: 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.
- **성능 병목**: 사용자 트래픽이 몰릴 경우 과부하 상태에 빠질 수 있다.


### 개략적 설계안 (개선된 버전)
![](https://velog.velcdn.com/images/hjinshin/post/2fc69db1-1f07-438e-aa78-63e0ff7dc82c/image.png)

> [!note] 개선사항
> - DB와 Cache를 알림 서버로부터 분리
> - 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이루어질 수 있도록 함
> - 메시지 큐를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊음

#### 각 컴포넌트별 역할
- **알림 서버**
    - 알림 전송 API: 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능
    - 알림 검증: 이메일 주소, 전화번호 등에 대한 기본적 검증 수행
    - 데이터베이스 또는 캐시 질의: 알림에 포함시킬 데이터를 쿼리
    - 알림 전송: 알림 데이터를 메시지 큐에 전송
- **캐시**: 사용자 정보, 단말 정보, 알림 템플릿 등을 캐시
- **데이터베이스**: 사용자, 알림, 설정 등 다양한 정보를 저장
- **메시지 큐**: 시스템 컴포넌트 간 의존성을 제거하기 위해 사용
    - 다량의 알림이 전송되어야 하는 경우를 대비한 버퍼 역할도 수행
- **작업 서버**: 메시지 큐에서 전송할 알림을 꺼내서 제3자 서비스로 전달

#### 전송 흐름
① API를 호출하여 알림 서버로 알림을 보낸다.
② 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져온다.  
③ 알림 서버는 전송할 알림에 맞는 이벤트를 만들어서 해당 이벤트를 위한 큐에 넣는다.
④ 작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.
⑤ 작업 서버는 알림을 제3자 서비스로 보낸다.
⑥ 제3자 서비스는 사용자 단말로 알림을 전송한다.


---
## 3. 상세 설계
### 안정성
분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보하기 위한 사항을 반드시 고려해야 한다.

#### 데이터 손실 방지
알림 시스템의 핵심 요구사항은 **알림 유실 방지**이다. 전송이 지연되거나 순서가 바뀌는 것은 허용되지만, 알림이 사라지는 것은 허용되지 않는다. 이를 보장하기 위해 모든 알림 데이터를 데이터베이스에 저장하고, 전송 실패 시 **재시도하는 기능**을 구현해야 한다.

#### 알림 중복 전송 방지
분산 시스템의 특성상 같은 알림이 중복 전송될 수 있다. 중복을 100% 방지하는 것은 불가능하므로([You Cannot Have Exactly-Once Delivery – Brave New Geek](https://bravenewgeek.com/you-cannot-have-exactly-once-delivery)), 시스템은 중복의 빈도를 줄이고 수신된 중복을 안전하게 처리하도록 설계해야 한다.

이를 위해 **이벤트 ID 기반의 중복 제거 메커니즘**을 도입한다. 알림을 처리하기 전, 해당 이벤트 ID가 이미 처리된 적 있는지 확인한다. 중복된 이벤트는 무시하고, 새로운 이벤트에 한해서만 알림을 발송한다.


### 추가로 필요한 컴포넌트 및 고려사항
#### 알림 템플릿
대부분의 알림 메시지는 유사한 형식을 공유한다. 알림 템플릿은 이러한 반복적인 구조를 재사용하여, 매번 메시지 전체를 새로 작성할 필요가 없도록 만든다.

예를 들어, `지금 [item_name]을 주문 또는 예약하세요!` 와 같은 템플릿을 정의하면, `[item_name]` 부분만 동적으로 변경하여 알림을 생성할 수 있다. 템플릿을 사용하면 메시지 형식의 일관성을 확보하고, 휴먼 에러(Human Error) 가능성을 줄이며, 알림 생성 시간을 단축시키는 효과를 얻는다.

> [!tip]
> 대규모 알림 시스템은 수백 개의 템플릿을 관리해야 하며, 이는 비즈니스 요구에 따라 수시로 변경될 수 있다. 매번 개발자가 이러한 변경 요청을 처리하는 것은 비효율적이므로, 운영 효율성을 높이기 위한 **알림 템플릿 관리 도구**가 필수적이다.
>
> 이 도구는 다음 핵심 요건을 반드시 충족해야 한다.
>
> - **템플릿 관리 기능:** 알림 템플릿을 조회, 생성, 수정, 삭제할 수 있는 UI를 제공한다.
> - **접근 제어:** 지정된 사용자에게만 접근 및 수정 권한을 부여하여 시스템의 안정성을 확보한다.
> - **변경 이력 관리:** 템플릿 변경은 즉시 운영 시스템에 영향을 미치므로, **누가, 언제, 무엇을** 수정했는지 모든 이력을 추적하고 기록하여 문제 발생 시 빠르게 대응할 수 있도록 해야 한다.

#### 알림 설정
사용자는 과도한 알림에 쉽게 피로감을 느낀다. 따라서 많은 서비스에서 사용자가 알림 설정을 상세히 조정할 수 있도록 하고 있다. 이는 데이터베이스에 사용자별, 채널별 수신 동의 여부를 저장하는 필드를 추가하여 간단히 구현할 수 있다.
> [!tip]
> 알림 설정은 비즈니스 요건에 따라 추가되거나 삭제될 수 있다. 매번 DB 스키마를 변경하는 것 대신, 모든 설정을 **단일 필드에 JSON 혹은 비트 마스크로 저장**하는 방안을 고려할 수 있다.
>
> 또한, 알림 발송 규칙 역시 수시로 변경될 수 있으므로, 설정 검증 로직을 특정 규칙에 종속되지 않는 **범용적인 구조**로 구현하여 **변경에 쉽게 대응**할 수 있도록 해야 한다.

#### 전송률 제한
단시간에 너무 많은 알림을 보내는 것은 사용자의 이탈을 유발하는 주요 원인이다. 이를 방지하기 위해 사용자별로 단위 시간당 수신 가능한 알림의 수를 제한하는 **전송률 제한** 정책을 적용한다. 이는 사용자가 알림 기능을 완전히 비활성화하는 것을 막는 중요한 보호 장치이다.

> [!tip]
> 알림 시스템을 호출하는 클라이언트의 오류로 인해 특정 사용자에게 의도치 않은 알림을 폭발적으로 전송하는 문제가 발생할 수 있다. 따라서 사용자 경험을 보호하고 시스템 과부하를 막기 위해, **사용자별 전송률을 제한하는 장치는 반드시 구현해야 한다.**

#### 재시도 방법
외부 연동(3rd-party) 서비스의 일시적인 오류로 알림 전송에 실패할 경우, 해당 알림은 **재시도 전용 큐(Retry Queue)** 로 이동시킨다. 이후 정해진 정책에 따라 재전송을 시도하며, 만약 실패가 지속적으로 발생하면 시스템 운영자에게 경고 알림을 보내 문제 상황을 인지시킨다.

#### 푸시 알림과 보안
신뢰할 수 없는 클라이언트의 무분별한 알림 전송을 막기 위해, iOS와 Android 푸시 알림 API는 **`appKey`와 `appSecret`을 이용한 인증 절차**를 거친다. 오직 인증되고 승인된 클라이언트만이 알림 전송 권한을 가질 수 있도록 API를 보호해야 한다.

#### 큐 모니터링
알림 시스템의 상태를 파악하는 핵심 지표는 **큐에 쌓여있는 메시지(알림)의 개수**이다. 큐의 길이가 지속적으로 증가한다는 것은 현재의 처리 용량(작업 서버)으로 트래픽을 감당하지 못하고 있다는 신호이다. 이 경우, 안정적인 서비스를 위해 즉시 작업 서버를 증설하여 대응해야 한다.

#### 이벤트 추적
알림의 효과를 측정하고 사용자 행동을 이해하기 위해 주요 지표를 추적해야 한다. **알림 확인율(Open Rate)**, **클릭률(Click-through Rate)**, 그리고 실제 앱 실행으로 이어진 **전환율(Conversion Rate)** 같은 데이터를 수집하고 분석하는 것은 서비스 개선에 필수적이다.

> [!tip]
> 알림 시스템은 유저 CS가 빈번하게 발생하므로, 모든 요청에 대한 **추적성 확보**가 매우 중요하다. 이를 위해 모든 알림 발송 건에 대한 상세 이력을 장기간 저장하고, 언제든 조회할 수 있어야 한다.
>
> 특히 전송 실패 시, 단순히 실패했다는 사실뿐만 아니라 **'알림 수신 거부', '서드파티 서비스 오류', 'DB 조회 오류'** 등 명확한 실패 원인을 반드시 기록해야 한다.


### 수정된 설계안
![](https://velog.velcdn.com/images/hjinshin/post/a870d555-819b-4ebc-881d-f0772a9f4d3e/image.png)

- 알림 서버에 인증과 전송률 제한 기능이 추가되었다.
- 전송 실패에 대응하기 위한 재시도 기능이 추가되었다. 전송에 실패한 알림은 다시 큐에 넣고 지정된 횟수만큼 재시도한다.
- 알림 템플릿을 사용하여 알림 생성 과정을 단순화하고 알림 내용의 일관성을 유지한다.
- 모니터링과 추적 시스템을 추가하여 시스템 상태를 확인하고 추후 시스템을 개선하기 쉽도록 하였다.


---
## 4. 마무리
이번 장에서는 푸시 알림, SMS, 이메일 등 다양한 채널을 지원하며 높은 확장성을 갖춘 알림 시스템을 설계했다. 각 컴포넌트 간의 결합도를 낮추고 비동기 처리를 위해 메시지 큐를 핵심 아키텍처로 활용했다.

- **안정성**: 메시지 전송 실패율을 낮추기 위해 안정적인 재시도 메커니즘 도입하였다.
- **보안**: 인증된 클라이언트만 알림을 보낼 수 있도록 appKey, appSecret 등의 메커니즘 이용하였다.
- **이벤트 추적 및 모니터링**: 알림 전송 과정을 추적하고 모니터링할 수 있는 시스템을 통합하였다.
- **사용자 설정**: 사용자가 알림 수신 설정을 조정할 수 있도록 하였다.
- **전송률 제한**: 사용자에게 알림을 보내는 빈도를 제한할 수 있도록 하였다.